@using System 
@using System.IO
@using FestivalMapper.App.Services
@using FestivalMapper.App.Models
@using FestivalMapper.App.Libraries

@inject ImagePickerService ImagePickerService
@inject MapStorageService MapStorageService

@page "/"
@page "/map"

<PageTitle>Festival Map</PageTitle>

<div class="container mb-3">
	<div class="row">
		<div class="col-md-4">
			<button class="btn btn-outline-primary" @onclick="ImportMapFromFile">📂 Import Map</button>
		</div>
		<div class="col-md-4">
			<button class="btn btn-primary" @onclick="PickImage">Pick Image</button>
		</div>
	</div>
</div>

@if (SavedMaps.Any())
{
    <h6>Saved Maps</h6>
    <ul class="list-group">
        @foreach (var savedMap in SavedMaps)
        {
            <li class="list-group-item d-flex justify-content-between align-items-center">
                <span>@savedMap.FestivalName</span>
                <button class="btn btn-sm btn-outline-primary" @onclick="() => LoadSelectedMap(savedMap)">Load</button>
                <button class="btn btn-sm btn-outline-danger" @onclick="() => DeleteMap(savedMap)">🗑️</button>
            </li>
        }
    </ul>
}

<div class="container-fluid">
	@if (!string.IsNullOrEmpty(FestivalMap.FestivalMapBase64))
	{
		<div class="row">
			<div class="input-group mb-3">
				<span class="input-group-text">Festival Name</span>
				<input @bind="FestivalMap.FestivalName" id="FestivalTitle" type="text" class="form-control" aria-label="Festival Name" />
			</div>

			<div class="input-group mb-3">
				<span class="input-group-text">Description</span>
				<textarea  @bind="FestivalMap.Description" class="form-control" rows="3" aria-label="Festival Description" />
			</div>
			<div class="d-flex gap-2 mb-3">
				<button class="btn btn-success" @onclick="SaveCurrentMap">💾 Save Map</button>
			</div>

			<button class="btn btn-secondary" @onclick="ToggleEditMode">
				@(IsEditMode ? "Exit Edit Mode" : "Edit Stages")
			</button>

		</div>

		<div>
			<label for="FestivalMap">Festival Map</label>
			<div class="map-container" @ref="MapContainerRef" @onclick="OnMapClick">
				
				<img class="map" src="data:image/png;base64,@FestivalMap.FestivalMapBase64" @ref="MapImageRef" @onload="GetMapImageSize" />


				@foreach (var stage in FestivalMap.Stages)
				{
					<div class="stage" style="top: @(stage.StageLocation.Y * MapImageHeight)px; left: @(stage.StageLocation.X * MapImageWidth)px; background-color: @stage.StageBg; border: 1px solid @stage.StageColor;">
						<p style="display: flex; justify-content: center; gap: 4px; color: #ffffff; text-align: center;">@stage.StageName</p>
						@if(IsEditMode)
						{
						<div class="edit-stage">
							<button style="font-size: 10px;" @onclick="() => EditStage(stage.Id)">✏️</button>
							<button style="font-size: 10px;" @onclick="() => RemoveStage(stage.Id)">🗑️</button>
						</div>
						}
					</div>
				}
			</div>
		</div>
	}
</div>

<script>
    window.getImageSize = (imgElement) => {
        const rect = imgElement.getBoundingClientRect();
        return {
            width: rect.width,
            height: rect.height
        };
    };
</script>

<style>
	.map-container {
		position: relative; 
		display: inline-block; 
		width: 100%; 
		max-width: 600px; 
		border: 5px solid #00ff00;
	}

	.map {
		width: 100%;
		height: auto;
	}

	.stage {
		position: absolute;
		width: @($"{stageMarkerRadius * 2}px"); 
		height: @($"{stageMarkerRadius * 2}px"); 
		border: 1px solid #ff0000; 
		background-color: #ff0000aa;
		border-radius: 50%; 
		transform: translate(-50%, -50%); 
		pointer-events: none;
	}

	.edit-stage {
		margin-top: 1px; 
		display: flex; 
		justify-content: center; 
		gap: 4px; 
		pointer-events: auto;
	}
</style>

<EditStageModal IsVisible="@IsEditModalVisible" Stage="@SelectedStage" OnClose="@CloseEditModal" OnSave="@SaveStageChanges" IsArtistConflicting="@IsArtistConflicting" OnArtistChange="@DetectScheduleConflicts" GetConflictMessage="GetConflictMessage" />


@code {

	private FestivalMap FestivalMap = new()
	{
		Stages = new List<Stage>()
	};

	private List<FestivalMap> SavedMaps = new();

	private Dictionary<string, List<(string ArtistName, string StageId)>> ConflictDetails = new();

	private ElementReference MapImageRef;
	private ElementReference MapContainerRef;

	private double MapImageWidth;
	private double MapImageHeight;

	private int stageIdCounter = 1;

	private bool IsEditMode = false;
	private bool IsEditModalVisible = false;
	private Stage? SelectedStage;

	private int stageMarkerRadius = 25;

	protected override async Task OnInitializedAsync()
	{
		await LoadMaps();
	}

	private async Task ImportMapFromFile()
	{
		try
		{
			var file = await FilePicker.Default.PickAsync(new PickOptions
			{
				PickerTitle = "Select Festival Map",
				FileTypes = FileTypeHelper.FestivalMap
			});

			if (file != null)
			{
				FestivalMap? importedFestivalMap = await MapStorageService.ImportMapAsync(file);
				if (importedFestivalMap != null)
				{
					LoadSelectedMap(importedFestivalMap);
				}

				await LoadMaps();
			}
		}
		catch (Exception)
		{

		}
	}

	private async Task SaveCurrentMap()
	{
		if (!string.IsNullOrEmpty(FestivalMap.FestivalName))
		{
			await MapStorageService.SaveMapAsync(FestivalMap);
			await LoadMaps();
		}
	}

	private async Task LoadMaps()
	{
		SavedMaps = await MapStorageService.LoadAllMapsAsync();
	}

	private Task LoadSelectedMap(FestivalMap map)
	{
		FestivalMap = map;
		DetectScheduleConflicts();
		return Task.CompletedTask;
	}

	private async Task DeleteMap(FestivalMap map)
	{
		if (FestivalMap == map)
		{
			FestivalMap = new();
		}

		await MapStorageService.DeleteMapAsync(map.FestivalName);
		await LoadMaps();

		StateHasChanged();
	}

	private string RandomStageColor()
	{
		var random = new Random();
		var color = $"#{random.Next(0x1000000):X6}";

		return color;
	}

	private bool IsArtistConflicting(string artistId)
	{
		return ConflictDetails.ContainsKey(artistId);
	}

	private string GetStageName(string stageId)
	{
		return FestivalMap.Stages.FirstOrDefault(x => x.Id == stageId).StageName;
	}

	private List<string> GetConflictMessage(string artistId)
	{
		if (!ConflictDetails.TryGetValue(artistId, out var conflicts) || conflicts.Count == 0)
			return new List<string>();


		var messages = conflicts
			.Select(c => $"Conflict with {c.ArtistName} at {GetStageName(c.StageId)}")
			.ToList();

		return messages;
	}

	private void DetectScheduleConflicts()
	{
		// reset conflicts
		ConflictDetails.Clear();

		var allArtists = FestivalMap.Stages.SelectMany(s => s.Artists.Where(a => a.SetTimeEnd.HasValue).Select(a => new
		{
			StageId = s.Id,
			StageName = s.StageName,
			Artist = a,
			Start = a.SetTimeStart,
			End = a.SetTimeEnd
		})).ToList();

		for (int i = 0; i < allArtists.Count; i++)
		{
			for (int j = i + 1; j < allArtists.Count; j++)
			{
				var a1 = allArtists[i];
				var a2 = allArtists[j];

				// skip same artist
				if (a1.Artist.Id == a2.Artist.Id)
				{
					continue;
				}

				var a1StartsBeforeA2End = a1.Start < a2.End;
				var a2StartsBeforeA1End = a2.Start < a1.End;

				bool overlaps = a1StartsBeforeA2End && a2StartsBeforeA1End;

				if (overlaps)
				{
					if (!ConflictDetails.ContainsKey(a1.Artist.Id))
					{
						ConflictDetails[a1.Artist.Id] = new();
					}

					if (!ConflictDetails.ContainsKey(a2.Artist.Id))
					{
						ConflictDetails[a2.Artist.Id] = new();
					}

					ConflictDetails[a1.Artist.Id].Add((a2.Artist.Name, a2.StageId));
					ConflictDetails[a2.Artist.Id].Add((a1.Artist.Name, a1.StageId));
				}
			}
		}
	}


	private async Task GetMapImageSize()
	{
		var size = await JS.InvokeAsync<DomRect>("getImageSize", MapImageRef);
		MapImageWidth = size.Width;
		MapImageHeight = size.Height;
	}

	private Task CloseEditModal()
	{
		IsEditModalVisible = false;
		SelectedStage = null;
		StateHasChanged();
		return Task.CompletedTask;
	}

	private Task SaveStageChanges()
	{
		// All data is bound to the selected stage, so we just close
		IsEditModalVisible = false;
		SelectedStage = null;
		return Task.CompletedTask;
	}

	private void ToggleEditMode()
	{
		IsEditMode = !IsEditMode;
	}

	private void RemoveStage(string id)
	{
		var stage = FestivalMap.Stages.FirstOrDefault(x => x.Id == id);
		if (stage != null)
		{
			FestivalMap.Stages.Remove(stage);
		}

		// delay exiting edit mode to prevent map click trigger
		if (!FestivalMap.Stages.Any())
		{
			_ = Task.Run(async () =>
			{
				await Task.Delay(100);
				await InvokeAsync(() =>
				{
					IsEditMode = false;
					StateHasChanged();
				});
			});			
		}

	}

	private void EditStage(string id)
	{
		SelectedStage = FestivalMap.Stages.FirstOrDefault(x => x.Id == id);
		if (SelectedStage != null)
		{
			IsEditModalVisible = true;
		}		
	}

	private async Task OnMapClick(MouseEventArgs e)
	{
		// don't add stage markers when in edit mode or there is no map size
		if (IsEditMode || MapImageHeight == 0 || MapImageWidth == 0)
		{
			return;
		}

		var clickBuffer = 10;

		var clickX = e.OffsetX;
		var clickY = e.OffsetY;

		// check if existing stage has been clicked
		foreach (var stage in FestivalMap.Stages)
		{
			var stageX = stage.StageLocation.X * MapImageWidth;
			var stageY = stage.StageLocation.Y * MapImageHeight;

			var dx = clickX - stageX;
			var dy = clickY - stageY;

			var distance = Math.Sqrt(dx * dx + dy * dy);

			if (distance <= (stageMarkerRadius + clickBuffer))
			{
				EditStage(stage.Id);
				return;
			}
		}


		// Convert to relative coordinates
		var relativeX = e.OffsetX / MapImageWidth;
		var relativeY = e.OffsetY / MapImageHeight;

		AddStage(relativeX, relativeY);
	}

	private void AddStage(double x, double y)
	{
		var newStage = new Stage
			{
				StageName = $"Stage {stageIdCounter - 1}",
				StageLocation = new Point(x, y),
				Artists = new List<Artist>(),
				StageColor = RandomStageColor()
			};

		FestivalMap.Stages.Add(newStage);
		stageIdCounter++;
	}


	private async Task PickImage()
	{
		var base64 = await ImagePickerService.PickImageAsBase64Async();
		if (base64 != null)
		{
			FestivalMap.FestivalMapBase64 = base64;
		}
	}

    [Inject] private IJSRuntime JS { get; set; }
}
