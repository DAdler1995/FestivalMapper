@using System 
@using System.IO
@using FestivalMapper.App.Services
@using FestivalMapper.App.Models
@using FestivalMapper.App.Libraries

@inject ImagePickerService ImagePickerService
@inject MapStorageService MapStorageService
@inject NavigationManager NavigationManager

@page "/map/{FileName}"
@page "/map"

<PageTitle>Festival Map</PageTitle>
<div class="container-fluid">
	@if (!string.IsNullOrEmpty(FestivalMap.FestivalMapBase64))
	{
		<div class="row">
			<div class="input-group mb-3">
				<span class="input-group-text">Festival Name</span>
				<input @oninput="async _ => await AutoSaveAsync()" @bind="FestivalMap.FestivalName" id="FestivalTitle" type="text" class="form-control" aria-label="Festival Name" />
			</div>

			<div class="input-group mb-3">
				<span class="input-group-text">Festival Start Date</span>
				<input @bind="FestivalMap.FestivalStartDate" class="form-control" type="date" aria-label="Festival Start Date" />
			</div>
		</div>

		<div>
			<div class="map-container" @ref="MapContainerRef" @onclick="OnMapClick">
				
				<img class="map" src="data:image/png;base64,@FestivalMap.FestivalMapBase64" @ref="MapImageRef" @onload="GetMapImageSize" />


				@foreach (var stage in FestivalMap.Stages)
				{
					<div class="stage d-flex justify-content-center align-items-center text-white text-center" style="top: @(stage.StageLocation.Y * MapImageHeight)px; left: @(stage.StageLocation.X * MapImageWidth)px; background-color: @stage.StageBg; border: 1px solid @stage.StageColor;">
						<span>@stage.StageName</span>
					</div>
				}
			</div>
		</div>
	}
</div>

<script>
    window.getImageSize = (imgElement) => {
        const rect = imgElement.getBoundingClientRect();
        return {
            width: rect.width,
            height: rect.height
        };
    };
</script>

<style>
	.map-container {
		position: relative; 
		display: inline-block; 
		width: 100%;
	}

	.map {
		width: 100%;
		height: auto;
	}

	.stage {
		position: absolute;
		width: @($"{stageMarkerRadius * 2}px"); 
		height: @($"{stageMarkerRadius * 2}px"); 
		border: 1px solid #ff0000; 
		background-color: #ff0000bf;
		border-radius: 50%; 
		transform: translate(-50%, -50%); 
		pointer-events: none;

		color: #fff;
		font-size: 0.65rem;
		font-weight: bold;
		cursor: pointer;
		overflow: hidden;
		white-space: wrap;
		text-overflow: ellipsis;
		padding: 2px;
	}
</style>

<EditStageModal 
	IsVisible="@IsEditModalVisible" 
	Stage="@SelectedStage" 
	OnClose="@CloseEditModal" 
	OnSave="@SaveStageChanges" 
	IsArtistConflicting="@IsArtistConflicting" 
	OnArtistChange="@DetectScheduleConflicts" 
	GetConflictMessage="GetConflictMessage" 
	OnDeleteStage="DeleteStage" 
	FestivalStartDate="FestivalMap.FestivalStartDate"
	AutoSave="AutoSaveAsync"/>


@code {
	[Parameter]
	public string? FileName { get; set; }

	private FestivalMap FestivalMap = new()
	{
		Stages = new List<Stage>()
	};

	private Dictionary<string, List<(string ArtistName, string StageId)>> ConflictDetails = new();

	private ElementReference MapImageRef;
	private ElementReference MapContainerRef;

	private double MapImageWidth;
	private double MapImageHeight;

	private int stageIdCounter = 1;

	private bool IsEditModalVisible = false;
	private Stage? SelectedStage;

	private int stageMarkerRadius = 25;
	private bool savePending;

	protected override async Task OnInitializedAsync()
	{
		if (string.IsNullOrEmpty(this.FileName))
		{
			FestivalMap = new() { Stages = new List<Stage>() };
			await PickImage();

			if (string.IsNullOrEmpty(FestivalMap.FestivalMapBase64))
			{
				// no image selected, redirect back to home
				NavigationManager.NavigateTo("/");
			}
			return;
		}

		var loadedFestivalMap = await MapStorageService.GetFestivalMapAsync(this.FileName);
		if (loadedFestivalMap == null)
		{
			// redirect back to the home page if the festival map cannot be loaded
			NavigationManager.NavigateTo("/");
			return;
		}

		FestivalMap = loadedFestivalMap;
	}

	private async Task AutoSaveAsync()
	{
		if (savePending || string.IsNullOrWhiteSpace(FestivalMap.FestivalName))
		{
			return;
		}

		savePending = true;
		await Task.Delay(500);

		await MapStorageService.SaveMapAsync(FestivalMap);
		savePending = false;
	}


	private async Task DeleteStage()
	{
		if (SelectedStage != null)
		{
			FestivalMap.Stages.Remove(SelectedStage);

			SelectedStage = null;
			IsEditModalVisible = false;
			DetectScheduleConflicts();
		}

		if (!FestivalMap.Stages.Any())
		{
			await Task.Delay(100);
			StateHasChanged();
		}

		await AutoSaveAsync();
	}

	private async Task SaveCurrentMap()
	{
		if (!string.IsNullOrEmpty(FestivalMap.FestivalName))
		{
			await MapStorageService.SaveMapAsync(FestivalMap);
		}
	}

	// might still be wanted/needed
	private async Task DeleteMap(FestivalMap map)
	{
		if (FestivalMap == map)
		{
			FestivalMap = new();
		}

		await MapStorageService.DeleteMapAsync(map.FestivalName);

		StateHasChanged();
	}

	private string RandomStageColor()
	{
		var random = new Random();
		var color = $"#{random.Next(0x1000000):X6}";

		return color;
	}

	private bool IsArtistConflicting(string artistId)
	{
		return ConflictDetails.ContainsKey(artistId);
	}

	private string GetStageName(string stageId)
	{
		return FestivalMap.Stages.FirstOrDefault(x => x.Id == stageId).StageName;
	}

	private List<string> GetConflictMessage(string artistId)
	{
		if (!ConflictDetails.TryGetValue(artistId, out var conflicts) || conflicts.Count == 0)
			return new List<string>();

		var messages = conflicts
			.Select(c => $"Conflict with {c.ArtistName} at {GetStageName(c.StageId)}")
			.ToList();

		return messages;
	}

	private void DetectScheduleConflicts()
	{
		// reset conflicts
		ConflictDetails.Clear();

		var allArtists = FestivalMap.Stages.SelectMany(s => s.Artists.Where(a => a.SetTimeEnd.HasValue).Select(a => new
		{
			StageId = s.Id,
			StageName = s.StageName,
			Artist = a,
			Start = a.SetTimeStart,
			End = a.SetTimeEnd
		})).ToList();

		for (int i = 0; i < allArtists.Count; i++)
		{
			for (int j = i + 1; j < allArtists.Count; j++)
			{
				var a1 = allArtists[i];
				var a2 = allArtists[j];

				// skip same artist
				if (a1.Artist.Id == a2.Artist.Id)
				{
					continue;
				}

				var a1StartsBeforeA2End = a1.Start < a2.End;
				var a2StartsBeforeA1End = a2.Start < a1.End;

				bool overlaps = a1StartsBeforeA2End && a2StartsBeforeA1End;

				if (overlaps)
				{
					if (!ConflictDetails.ContainsKey(a1.Artist.Id))
					{
						ConflictDetails[a1.Artist.Id] = new();
					}

					if (!ConflictDetails.ContainsKey(a2.Artist.Id))
					{
						ConflictDetails[a2.Artist.Id] = new();
					}

					ConflictDetails[a1.Artist.Id].Add((a2.Artist.Name, a2.StageId));
					ConflictDetails[a2.Artist.Id].Add((a1.Artist.Name, a1.StageId));
				}
			}
		}
	}


	private async Task GetMapImageSize()
	{
		var size = await JS.InvokeAsync<DomRect>("getImageSize", MapImageRef);
		MapImageWidth = size.Width;
		MapImageHeight = size.Height;
	}

	private Task CloseEditModal()
	{
		IsEditModalVisible = false;
		SelectedStage = null;
		StateHasChanged();
		return Task.CompletedTask;
	}

	private async Task SaveStageChanges()
	{
		// All data is bound to the selected stage, so we just close
		IsEditModalVisible = false;
		SelectedStage = null;
		await SaveCurrentMap();
	}

	private void EditStage(string id)
	{
		SelectedStage = FestivalMap.Stages.FirstOrDefault(x => x.Id == id);
		if (SelectedStage != null)
		{
			IsEditModalVisible = true;
		}		
	}

	private async Task OnMapClick(MouseEventArgs e)
	{
		// don't add stage markers when in edit mode or there is no map size
		if (MapImageHeight == 0 || MapImageWidth == 0)
		{
			return;
		}

		var clickBuffer = 10;

		var clickX = e.OffsetX;
		var clickY = e.OffsetY;

		// check if existing stage has been clicked
		foreach (var stage in FestivalMap.Stages)
		{
			var stageX = stage.StageLocation.X * MapImageWidth;
			var stageY = stage.StageLocation.Y * MapImageHeight;

			var dx = clickX - stageX;
			var dy = clickY - stageY;

			var distance = Math.Sqrt(dx * dx + dy * dy);

			if (distance <= (stageMarkerRadius + clickBuffer))
			{
				EditStage(stage.Id);
				return;
			}
		}


		// Convert to relative coordinates
		var relativeX = e.OffsetX / MapImageWidth;
		var relativeY = e.OffsetY / MapImageHeight;

		await AddStage(relativeX, relativeY);
	}

	private async Task AddStage(double x, double y)
	{
		var newStage = new Stage
			{
				StageName = $"Stage {stageIdCounter - 1}",
				StageLocation = new Point(x, y),
				Artists = new List<Artist>(),
				StageColor = RandomStageColor()
			};

		FestivalMap.Stages.Add(newStage);
		stageIdCounter++;

		await AutoSaveAsync();
	}


	private async Task PickImage()
	{
		var base64 = await ImagePickerService.PickImageAsBase64Async();
		if (base64 != null)
		{
			FestivalMap.FestivalMapBase64 = base64;
		}
	}

    [Inject] private IJSRuntime JS { get; set; }
}
